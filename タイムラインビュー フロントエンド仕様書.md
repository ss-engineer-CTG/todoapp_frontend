# タイムラインビュー フロントエンド仕様書

**ドキュメントバージョン:** 1.0.0  
**最終更新日:** 2025-05-15  
**ステータス:** ドラフト  

---

## 1. 概要

### 1.1 目的と範囲

本仕様書はタスク管理アプリケーションのコア機能である「タイムラインビュー」コンポーネントのフロントエンド実装に関する詳細を定義します。このコンポーネントは、タスクの時間的関係性を視覚化し、直感的な操作でタスクの期間調整と依存関係の確認を可能にします。

### 1.2 主要機能

- **表示モード切替**: 日/週/月単位での表示切替
- **ドラッグ＆ドロップ**: タスク期間の視覚的編集
- **ステータス表示**: タスクのステータス（遅延/進行中/未来/完了）の色分け
- **ズーム機能**: 表示密度の調整
- **期間ナビゲーション**: 今日の日付を中心とした表示と期間移動

### 1.3 技術スタック

| 項目 | 使用技術 |
|------|---------|
| フレームワーク | React 18+ |
| 言語 | TypeScript 5.0+ |
| スタイリング | Tailwind CSS 3.0+ |
| ブラウザ対応 | Chrome 90+, Firefox 88+, Safari 14+, Edge 90+ |
| アクセシビリティ | WCAG 2.1 AA準拠 |

---

## 2. コンポーネント構造

### 2.1 コンポーネント階層図

```
TimelineView (ルートコンポーネント)
├── TimelineHeader (コントロールパネル)
├── TimelineDayHeader (日付表示)
└── TimelineItemList (タスク一覧)
    └── TimelineItem[] (個別タスク)
        └── TaskDetailPopover (詳細ポップアップ)
```

### 2.2 コンポーネント間データフロー

コンポーネント間のデータフローは以下のとおりです：

1. TimelineViewから子コンポーネントへProps経由でデータを渡します
2. 子コンポーネントからTimelineViewへイベントコールバックでアクションを伝えます
3. TimelineViewで状態を更新し、更新された状態が子コンポーネントに反映されます

例えば：
- TimelineHeaderのビューモード切替ボタンが押されると、そのイベントがTimelineViewに伝えられます
- TimelineViewがviewModeステートを更新します
- 更新されたviewModeが他のコンポーネントに反映され、表示が変わります

---

## 3. 個別コンポーネント仕様

### 3.1 TimelineView

**概要**: タイムラインビューのルートコンポーネント。全体のレイアウト構造を提供し、子コンポーネント間のデータとイベントを管理します。

#### 3.1.1 プロパティ

```typescript
interface TimelineViewProps {
  // 必須プロパティ
  tasks: Task[];                         // タスクデータ配列
  
  // 任意プロパティ
  project?: Project;                     // プロジェクト情報
  defaultViewMode?: 'day' | 'week' | 'month'; // デフォルト表示モード (デフォルト: 'week')
  defaultStartDate?: Date;               // 初期表示開始日 (デフォルト: 今日)
  onTaskUpdate?: (task: Task) => void;   // タスク更新時のコールバック
  showCompletedTasks?: boolean;          // 完了タスク表示フラグ (デフォルト: true)
  readOnly?: boolean;                    // 読み取り専用モード (デフォルト: false)
  className?: string;                    // 追加CSSクラス
}
```

#### 3.1.2 状態管理

```typescript
// 内部状態
const [viewMode, setViewMode] = useState<'day' | 'week' | 'month'>(props.defaultViewMode || 'week');
const [startDate, setStartDate] = useState<Date>(calculateStartDate());
const [endDate, setEndDate] = useState<Date>(calculateEndDate(startDate, viewMode));
const [zoomLevel, setZoomLevel] = useState<number>(100);
const [selectedTaskId, setSelectedTaskId] = useState<string | null>(null);
const [draggingTaskId, setDraggingTaskId] = useState<string | null>(null);
const [showCompletedTasks, setShowCompletedTasks] = useState<boolean>(props.showCompletedTasks ?? true);
```

#### 3.1.3 レンダリング

```tsx
return (
  <div className={`timeline-view ${className}`}>
    <TimelineHeader
      viewMode={viewMode}
      onViewModeChange={handleViewModeChange}
      onNavigate={handleNavigate}
      zoomLevel={zoomLevel}
      onZoomChange={handleZoomChange}
      showCompletedTasks={showCompletedTasks}
      onShowCompletedTasksChange={handleShowCompletedTasksChange}
    />
    
    <TimelineDayHeader
      startDate={startDate}
      endDate={endDate}
      dayWidth={calculateDayWidth()}
      todayIndicator
      highlightWeekends
    />
    
    <TimelineItemList
      tasks={filteredTasks}
      startDate={startDate}
      dayWidth={calculateDayWidth()}
      onTaskSelect={handleTaskSelect}
      onTaskDragStart={handleTaskDragStart}
      onTaskDragEnd={handleTaskDragEnd}
      selectedTaskId={selectedTaskId}
      draggingTaskId={draggingTaskId}
      readOnly={readOnly}
    />
  </div>
);
```

#### 3.1.4 イベントハンドラ

```typescript
// 表示モード変更
const handleViewModeChange = (newMode: 'day' | 'week' | 'month') => {
  // 現在の中心日付を保持したまま表示範囲を更新
  // コード例は4.1.1節参照
};

// 期間ナビゲーション
const handleNavigate = (direction: 'prev' | 'next' | 'today') => {
  // 表示期間を移動
  // コード例は4.1.2節参照
};

// タスク選択
const handleTaskSelect = (taskId: string) => {
  setSelectedTaskId(taskId === selectedTaskId ? null : taskId);
};

// タスクドラッグ開始
const handleTaskDragStart = (args: DragStartArgs) => {
  setDraggingTaskId(args.taskId);
};

// タスクドラッグ終了
const handleTaskDragEnd = (args: DragEndArgs) => {
  if (props.onTaskUpdate && args.taskId) {
    const task = tasks.find(t => t.id === args.taskId);
    if (task) {
      const updatedTask = {
        ...task,
        startDate: args.newStartDate || task.startDate,
        endDate: args.newEndDate || task.endDate
      };
      props.onTaskUpdate(updatedTask);
    }
  }
  setDraggingTaskId(null);
};
```

### 3.2 TimelineHeader

**概要**: タイムラインの上部に配置され、表示モードやナビゲーションコントロールを提供するコンポーネント。

#### 3.2.1 プロパティ

```typescript
interface TimelineHeaderProps {
  viewMode: 'day' | 'week' | 'month';
  onViewModeChange: (mode: 'day' | 'week' | 'month') => void;
  onNavigate: (direction: 'prev' | 'next' | 'today') => void;
  zoomLevel: number;
  onZoomChange: (level: number) => void;
  showCompletedTasks: boolean;
  onShowCompletedTasksChange: (show: boolean) => void;
  className?: string;
}
```

#### 3.2.2 レンダリング

```tsx
return (
  <div className={`timeline-header ${className}`}>
    {/* 表示モード切替 */}
    <div className="view-mode-controls">
      <button
        className={`btn ${viewMode === 'day' ? 'btn-active' : ''}`}
        onClick={() => onViewModeChange('day')}
      >
        日
      </button>
      <button
        className={`btn ${viewMode === 'week' ? 'btn-active' : ''}`}
        onClick={() => onViewModeChange('week')}
      >
        週
      </button>
      <button
        className={`btn ${viewMode === 'month' ? 'btn-active' : ''}`}
        onClick={() => onViewModeChange('month')}
      >
        月
      </button>
    </div>
    
    {/* 期間ナビゲーション */}
    <div className="navigation-controls">
      <button className="btn" onClick={() => onNavigate('prev')}>◀</button>
      <button className="btn" onClick={() => onNavigate('today')}>今日</button>
      <button className="btn" onClick={() => onNavigate('next')}>▶</button>
    </div>
    
    {/* ズーム操作 */}
    <div className="zoom-controls">
      <button className="btn" onClick={() => onZoomChange(Math.max(50, zoomLevel - 10))}>-</button>
      <span>{zoomLevel}%</span>
      <button className="btn" onClick={() => onZoomChange(Math.min(200, zoomLevel + 10))}>+</button>
    </div>
    
    {/* 完了タスク表示切替 */}
    <div className="completed-tasks-control">
      <label>
        <input
          type="checkbox"
          checked={showCompletedTasks}
          onChange={(e) => onShowCompletedTasksChange(e.target.checked)}
        />
        完了済みを表示
      </label>
    </div>
    
    {/* ステータス凡例 */}
    <div className="status-legend">
      <div className="legend-item">
        <span className="color-box delayed"></span>
        <span>遅延</span>
      </div>
      <div className="legend-item">
        <span className="color-box active"></span>
        <span>進行中</span>
      </div>
      <div className="legend-item">
        <span className="color-box future"></span>
        <span>未来</span>
      </div>
      <div className="legend-item">
        <span className="color-box completed"></span>
        <span>完了</span>
      </div>
    </div>
  </div>
);
```

### 3.3 TimelineDayHeader

**概要**: 日付と月表示を行い、タイムラインのグリッド構造の基準となるコンポーネント。

#### 3.3.1 プロパティ

```typescript
interface TimelineDayHeaderProps {
  startDate: Date;                  // 表示開始日
  endDate: Date;                    // 表示終了日
  dayWidth: number;                 // 1日あたりの幅(px)
  todayIndicator?: boolean;         // 今日表示有無
  highlightWeekends?: boolean;      // 週末ハイライト有無
  className?: string;
}
```

#### 3.3.2 レンダリング

```tsx
// 表示する日付の配列を生成
const days = getDaysBetween(startDate, endDate);
const today = new Date();

return (
  <div
    className={`timeline-day-header ${className}`}
    style={{ position: 'sticky', top: 0, zIndex: 10 }}
  >
    {/* 月表示行 */}
    <div className="month-row">
      {getMonthLabels(days).map((monthLabel, index) => (
        <div
          key={`month-${index}`}
          className="month-label"
          style={{ width: monthLabel.width }}
        >
          {monthLabel.label}
        </div>
      ))}
    </div>
    
    {/* 日付行 */}
    <div className="day-row">
      {days.map((day, index) => {
        const isToday = isSameDay(day, today);
        const isWeekend = isWeekDay(day);
        
        return (
          <div
            key={`day-${index}`}
            className={`day-column ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}`}
            style={{ width: `${dayWidth}px` }}
          >
            <div className="day-number">{format(day, 'd')}</div>
            <div className="day-name">{format(day, 'E')}</div>
          </div>
        );
      })}
    </div>
  </div>
);
```

### 3.4 TimelineItem

**概要**: 個々のタスクバーを表示するコンポーネント。タスクの期間とステータスを視覚化し、ドラッグ操作を処理します。

#### 3.4.1 プロパティ

```typescript
interface TimelineItemProps {
  task: Task;                           // タスクデータ
  dayWidth: number;                     // 1日あたりの幅(px)
  startDate: Date;                      // タイムライン表示開始日
  rowHeight: number;                    // 行の高さ(px)
  index: number;                        // 表示順インデックス
  isSelected: boolean;                  // 選択状態
  onSelect: (taskId: string) => void;   // 選択イベントハンドラ
  onDragStart: (args: DragStartArgs) => void; // ドラッグ開始ハンドラ
  onDragEnd: (args: DragEndArgs) => void;     // ドラッグ終了ハンドラ
  readOnly?: boolean;                   // 読み取り専用モード
  className?: string;
}
```

#### 3.4.2 ステータス計算

```typescript
// タスクのステータスを計算
const taskStatus = useTaskStatus(task);

// ステータス判定ロジック (useTaskStatus内部)
const determineTaskStatus = (task: Task, today: Date = new Date()): TaskStatus => {
  // 完了タスク
  if (task.completed) {
    return 'completed';
  }
  
  // 遅延タスク（終了日が過ぎているが未完了）
  if (isAfter(today, task.endDate)) {
    return 'delayed';
  }
  
  // 進行中タスク（今日が開始日と終了日の間）
  if (
    (isAfter(today, task.startDate) || isSameDay(today, task.startDate)) &&
    (isBefore(today, task.endDate) || isSameDay(today, task.endDate))
  ) {
    return 'active';
  }
  
  // 未来タスク（開始日がまだ来ていない）
  return 'future';
};
```

#### 3.4.3 位置計算

```typescript
// タスクの表示位置とサイズを計算
const position = calculateTaskPosition(task, startDate, dayWidth);
const top = index * rowHeight + 5; // 5pxは余白

// 位置計算ロジック
const calculateTaskPosition = (
  task: Task,
  startDate: Date,
  dayWidth: number
): { left: number; width: number } => {
  // 表示開始日からの日数を計算
  const daysDiff = differenceInDays(task.startDate, startDate);
  
  // タスクの期間を日数に変換して幅を計算
  const taskDuration = Math.max(
    1, 
    differenceInDays(task.endDate, task.startDate) + 1
  );
  const width = taskDuration * dayWidth;
  
  return {
    left: Math.max(0, daysDiff * dayWidth),
    width
  };
};
```

#### 3.4.4 レンダリング

```tsx
return (
  <div
    className={`
      task-item 
      ${taskStatus.status} 
      ${isSelected ? 'selected' : ''} 
      ${className || ''}
    `}
    style={{
      position: 'absolute',
      left: `${position.left}px`,
      top: `${top}px`,
      width: `${position.width}px`,
      height: `${rowHeight - 10}px`, // 10pxは上下の余白
      backgroundColor: taskStatus.backgroundColor,
      borderColor: taskStatus.borderColor,
      color: taskStatus.textColor
    }}
    onClick={() => onSelect(task.id)}
  >
    {/* 開始日ドラッグハンドル */}
    {!readOnly && (
      <div
        className="drag-handle-start"
        onMouseDown={(e) => handleDragStart(e, 'start')}
        onTouchStart={(e) => handleTouchDragStart(e, 'start')}
      />
    )}
    
    {/* タスク内容 */}
    <div className="task-content">
      <div className="task-title">{task.title}</div>
      <div className="task-dates">
        {format(task.startDate, 'MM/dd')} - {format(task.endDate, 'MM/dd')}
      </div>
    </div>
    
    {/* 終了日ドラッグハンドル */}
    {!readOnly && (
      <div
        className="drag-handle-end"
        onMouseDown={(e) => handleDragStart(e, 'end')}
        onTouchStart={(e) => handleTouchDragStart(e, 'end')}
      />
    )}
    
    {/* タスク詳細ポップオーバー（ホバー時に表示） */}
    <TaskDetailPopover task={task} />
  </div>
);
```

#### 3.4.5 ドラッグイベントハンドラ

```typescript
// マウスドラッグ開始
const handleDragStart = (e: React.MouseEvent, type: 'start' | 'end' | 'move') => {
  e.preventDefault();
  
  // タスク全体をドラッグする場合
  const dragType = type || 'move';
  
  onDragStart({
    taskId: task.id,
    type: dragType,
    initialX: e.clientX,
    initialY: e.clientY
  });
  
  // グローバルのマウスイベントリスナーを設定
  document.addEventListener('mousemove', handleDragMove);
  document.addEventListener('mouseup', handleDragEnd);
};

// タッチドラッグ開始（モバイル向け）
const handleTouchDragStart = (e: React.TouchEvent, type: 'start' | 'end' | 'move') => {
  // タッチイベント対応のコード
  // ...省略...
};
```

### 3.5 TaskDetailPopover

**概要**: タスクにホバーした際に表示される詳細情報ポップアップ。

#### 3.5.1 プロパティ

```typescript
interface TaskDetailPopoverProps {
  task: Task;                      // タスク詳細データ
  position?: 'top' | 'bottom';     // 表示位置
  className?: string;
}
```

#### 3.5.2 レンダリング

```tsx
const [isVisible, setIsVisible] = useState(false);
const statusInfo = useTaskStatus(task);
const taskDuration = differenceInDays(task.endDate, task.startDate) + 1;

return (
  <div className="popover-wrapper">
    {/* ポップオーバートリガー */}
    <div 
      className="popover-trigger"
      onMouseEnter={() => setIsVisible(true)}
      onMouseLeave={() => setIsVisible(false)}
    >
      {/* 空のトリガー要素 */}
    </div>
    
    {/* ポップオーバーコンテンツ */}
    {isVisible && (
      <div className={`task-detail-popover ${position || 'top'} ${className || ''}`}>
        <div className="popover-header">
          <h3 className="task-title">{task.title}</h3>
          <span className={`status-badge ${statusInfo.status}`}>
            {statusInfo.label}
          </span>
        </div>
        
        <div className="popover-body">
          <div className="detail-row">
            <span className="detail-label">期間:</span>
            <span className="detail-value">
              {format(task.startDate, 'yyyy/MM/dd')} - {format(task.endDate, 'yyyy/MM/dd')}
              （{taskDuration}日）
            </span>
          </div>
          
          {task.assignee && (
            <div className="detail-row">
              <span className="detail-label">担当者:</span>
              <span className="detail-value">{task.assignee.name}</span>
            </div>
          )}
          
          {task.priority && (
            <div className="detail-row">
              <span className="detail-label">優先度:</span>
              <span className="detail-value">{getPriorityLabel(task.priority)}</span>
            </div>
          )}
          
          {task.tags && task.tags.length > 0 && (
            <div className="detail-row">
              <span className="detail-label">タグ:</span>
              <div className="tag-list">
                {task.tags.map(tag => (
                  <span key={tag} className="tag">{tag}</span>
                ))}
              </div>
            </div>
          )}
          
          {task.description && (
            <div className="detail-row">
              <span className="detail-label">説明:</span>
              <div className="description">{task.description}</div>
            </div>
          )}
        </div>
      </div>
    )}
  </div>
);
```

---

## 4. インタラクション仕様

### 4.1 表示モード管理

#### 4.1.1 表示モードの切替

タイムラインビューは3つの表示モードをサポートします：

- **日モード** - 詳細表示（1日=50px）
- **週モード** - 標準表示（1日=30px）
- **月モード** - 概要表示（1日=20px）

```typescript
const handleViewModeChange = (newMode: ViewMode) => {
  // 現在の中心日付を取得
  const currentCenterDate = addDays(startDate, Math.floor(visibleDays / 2));
  
  // 新しいモードの表示日数を取得
  const newVisibleDays = calculateVisibleDays(newMode);
  
  // 新しい開始日と終了日を計算
  const newStartDate = addDays(currentCenterDate, -Math.floor(newVisibleDays / 2));
  const newEndDate = addDays(newStartDate, newVisibleDays - 1);
  
  // 状態を更新
  setViewMode(newMode);
  setStartDate(newStartDate);
  setEndDate(newEndDate);
  setZoomLevel(100); // デフォルトに戻す
};
```

#### 4.1.2 期間ナビゲーション

期間ナビゲーションは以下の操作をサポートします：

- **前へ** - 表示期間を1単位（日/週/月モードに応じて）過去へ移動
- **次へ** - 表示期間を1単位未来へ移動
- **今日** - 今日の日付を中心に表示

```typescript
const handleNavigate = (direction: 'prev' | 'next' | 'today') => {
  const visibleDays = differenceInDays(endDate, startDate) + 1;
  
  if (direction === 'prev') {
    // 表示モードに応じた移動単位を計算
    const moveUnits = viewMode === 'day' ? 7 : (viewMode === 'week' ? 14 : 30);
    setStartDate(addDays(startDate, -moveUnits));
    setEndDate(addDays(endDate, -moveUnits));
  } 
  else if (direction === 'next') {
    const moveUnits = viewMode === 'day' ? 7 : (viewMode === 'week' ? 14 : 30);
    setStartDate(addDays(startDate, moveUnits));
    setEndDate(addDays(endDate, moveUnits));
  } 
  else if (direction === 'today') {
    // 今日を中心にした表示範囲を計算
    const today = new Date();
    const newStartDate = addDays(today, -Math.floor(visibleDays / 2));
    setStartDate(newStartDate);
    setEndDate(addDays(newStartDate, visibleDays - 1));
  }
};
```

### 4.2 ドラッグ＆ドロップ機能

#### 4.2.1 ドラッグタイプ

タイムラインビューは3種類のドラッグ操作をサポートします：

1. **開始日ドラッグ** - タスクバーの左端ハンドルをドラッグして開始日を調整
2. **終了日ドラッグ** - タスクバーの右端ハンドルをドラッグして終了日を調整
3. **全体移動** - タスクバー本体をドラッグして開始日と終了日を同時に調整

#### 4.2.2 ドラッグフロー

ドラッグ操作のフロー：

1. **ドラッグ開始**
   - タスクID、ドラッグタイプ、初期座標を記録
   - ドラッグ状態をアクティブに設定

2. **ドラッグ中**
   - マウス移動量から日数の変化を計算
   - 日付グリッドにスナップ
   - 制約条件をチェック（開始日 <= 終了日）
   - プレビュー情報を更新

3. **ドラッグ終了**
   - 最終的な日付変更を計算
   - タスクデータを更新
   - ドラッグ状態をリセット

#### 4.2.3 スナップ機能

ドラッグ操作中、タスクは日付グリッドに自動的にスナップします：

```typescript
const snapToGrid = (date: Date): Date => {
  // 日付の時刻部分をリセットして日単位でスナップ
  return startOfDay(date);
};
```

#### 4.2.4 ドラッグ中のプレビュー

ドラッグ中の視覚的フィードバック：

- ドラッグ中のタスクバーは半透明化される
- プレビュー情報（新しい開始日/終了日/期間）がツールチップで表示される

```tsx
{/* ドラッグプレビュー情報 */}
{isDragging && dragPreview.taskId && (
  <div className="drag-preview-tooltip">
    <div className="preview-title">
      {tasks.find(t => t.id === dragPreview.taskId)?.title}
    </div>
    {dragPreview.startDate && (
      <div className="preview-dates">
        開始日: {format(dragPreview.startDate, 'yyyy/MM/dd')}
      </div>
    )}
    {dragPreview.endDate && (
      <div className="preview-dates">
        終了日: {format(dragPreview.endDate, 'yyyy/MM/dd')}
      </div>
    )}
    {dragPreview.startDate && dragPreview.endDate && (
      <div className="preview-duration">
        期間: {differenceInDays(dragPreview.endDate, dragPreview.startDate) + 1}日
      </div>
    )}
  </div>
)}
```

### 4.3 キーボードナビゲーション

タイムラインビューは以下のキーボードショートカットをサポートします：

| キー | アクション |
|------|----------|
| 矢印キー（上/下） | タスク間の移動 |
| 矢印キー（左/右） | タスク期間の調整 |
| スペースキー | タスク完了状態の切り替え |
| Delete | タスクの削除 |
| Esc | ドラッグ操作のキャンセル |
| Shift + 左矢印 | 前の期間に移動 |
| Shift + 右矢印 | 次の期間に移動 |
| Shift + T | 今日に移動 |
| +/- | ズームイン/ズームアウト |
| 0 | ズームリセット |

```typescript
const KEYBOARD_SHORTCUTS = {
  ArrowUp: 'focusPreviousTask',
  ArrowDown: 'focusNextTask',
  ArrowLeft: 'decreaseDuration',
  ArrowRight: 'increaseDuration',
  ' ': 'toggleCompleted',  // スペースキー
  Delete: 'deleteTask',
  Escape: 'cancelDrag',
  'Shift+ArrowLeft': 'navigatePrev',
  'Shift+ArrowRight': 'navigateNext',
  'Shift+T': 'navigateToday',
  '+': 'zoomIn',
  '-': 'zoomOut',
  '0': 'resetZoom'
};
```

---

## 5. スタイリング仕様

### 5.1 カラーシステム

#### 5.1.1 ベースカラー

| 用途 | カラーコード | 変数名 |
|------|------------|--------|
| 背景色 | #F8F9FA | --color-bg |
| コンテンツ背景 | #FFFFFF | --color-content-bg |
| 境界線 | #E2E8F0 | --color-border |
| テキスト（主） | #333333 | --color-text-primary |
| テキスト（副） | #6B7280 | --color-text-secondary |

#### 5.1.2 アクセントカラー

| 用途 | カラーコード | 変数名 |
|------|------------|--------|
| プライマリ | #3B82F6 | --color-primary |
| プライマリ（暗） | #1E40AF | --color-primary-dark |
| プライマリ（明） | #BFDBFE | --color-primary-light |
| 今日ライン | #EF4444 | --color-today |
| 依存関係 | #9333EA | --color-dependency |

#### 5.1.3 ステータスカラー

| ステータス | 背景色 | 枠線色 | テキスト色 |
|-----------|-------|--------|----------|
| 遅延 | #FECACA | #EF4444 | #B91C1C |
| 進行中 | #BFDBFE | #3B82F6 | #1E40AF |
| 未来 | #A7F3D0 | #10B981 | #047857 |
| 完了 | #E5E7EB | #9CA3AF | #4B5563 |

### 5.2 スペーシングとグリッド

#### 5.2.1 基本単位

```css
/* スペーシング変数 */
--spacing-unit: 4px;
--spacing-1: 4px;   /* 0.25rem */
--spacing-2: 8px;   /* 0.5rem */
--spacing-3: 12px;  /* 0.75rem */
--spacing-4: 16px;  /* 1rem */
--spacing-5: 20px;  /* 1.25rem */
--spacing-6: 24px;  /* 1.5rem */
--spacing-8: 32px;  /* 2rem */
--spacing-10: 40px; /* 2.5rem */
--spacing-12: 48px; /* 3rem */
```

#### 5.2.2 タイムライングリッド

```css
/* タイムラインの行の高さ */
--timeline-row-height: 40px;

/* タスクバーの高さ */
--task-bar-height: 30px;

/* 1日あたりの基本幅（表示モードごと） */
--day-width-day-mode: 50px;
--day-width-week-mode: 30px;
--day-width-month-mode: 20px;

/* 最小/最大ズームレベル */
--min-zoom: 50%;
--max-zoom: 200%;
```

### 5.3 インタラクションスタイル

#### 5.3.1 ホバー効果

```css
/* タスクバーのホバー効果 */
.task-bar:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transition: all 0.2s ease;
}

/* ドラッグハンドルのホバー効果 */
.drag-handle:hover {
  background-color: rgba(255, 255, 255, 0.6);
}
```

#### 5.3.2 ドラッグ中のスタイル

```css
/* ドラッグ中のタスクバー */
.task-bar.dragging {
  opacity: 0.7;
  transform: scale(1.02);
  z-index: 100;
}

/* ドラッグ中のカーソルスタイル */
.task-bar {
  cursor: grab;
}
.task-bar:active {
  cursor: grabbing;
}
.drag-handle.left {
  cursor: w-resize;
}
.drag-handle.right {
  cursor: e-resize;
}
```

#### 5.3.3 トランジション

```css
/* 共通トランジション */
.task-bar,
.drag-handle {
  transition: all 0.2s ease;
}

/* ポップオーバートランジション */
.task-detail-popover {
  opacity: 0;
  transform: translateY(5px);
  transition: opacity 0.2s ease, transform 0.2s ease;
}
.task-detail-popover.visible {
  opacity: 1;
  transform: translateY(0);
}
```

---

## 6. アクセシビリティ要件

### 6.1 ARIA属性

```tsx
<div
  role="application"
  aria-label="タイムラインビュー"
  className="timeline-view"
>
  {/* TimelineHeader */}
  <div
    role="toolbar"
    aria-label="タイムラインコントロール"
    className="timeline-header"
  >
    {/* コントロール要素 */}
  </div>

  {/* TimelineDayHeader */}
  <div
    role="rowgroup"
    aria-label="日付ヘッダー"
    className="timeline-day-header"
  >
    {days.map((day, index) => (
      <div
        key={index}
        role="columnheader"
        aria-label={formatDate(day, 'yyyy年MM月dd日（E）')}
        className="day-column"
      >
        {/* 日付表示 */}
      </div>
    ))}
  </div>

  {/* タスクリスト */}
  <div
    role="grid"
    aria-label="タスクタイムライン"
    className="timeline-grid"
  >
    {tasks.map((task) => (
      <div
        key={task.id}
        role="row"
        className="task-row"
      >
        <div
          role="gridcell"
          className="task-label"
        >
          {task.title}
        </div>
        
        <div
          role="gridcell"
          className="task-cell"
        >
          <div
            role="button"
            tabIndex={0}
            aria-label={`${task.title}: ${formatDate(task.startDate, 'MM/dd')}から${formatDate(task.endDate, 'MM/dd')}まで, ステータス: ${getTaskStatusLabel(task)}`}
            aria-grabbed={isDragging && dragTaskId === task.id}
            aria-describedby={`task-${task.id}-description`}
            className="task-bar"
          >
            {/* タスクバーコンテンツ */}
          </div>
        </div>
      </div>
    ))}
  </div>
</div>
```

### 6.2 キーボード操作

- Tab: フォーカスを次の操作可能要素に移動
- Shift+Tab: フォーカスを前の操作可能要素に移動
- スペース/Enter: フォーカス中の要素をアクティブ化（タスク選択など）
- 4.3節に記載のショートカットキー

### 6.3 色覚対応

色のみに依存しない情報伝達：

```tsx
<div className="task-bar">
  {/* ステータスアイコンを追加 */}
  {status === 'delayed' && <span className="status-icon" aria-hidden="true">⚠️</span>}
  {status === 'active' && <span className="status-icon" aria-hidden="true">▶️</span>}
  {status === 'future' && <span className="status-icon" aria-hidden="true">⏳</span>}
  {status === 'completed' && <span className="status-icon" aria-hidden="true">✓</span>}
  
  <span className="task-title">{task.title}</span>
  
  {/* テキストとしてもステータスを表示 */}
  <span className="status-label">{getTaskStatusLabel(task)}</span>
</div>
```

---

## 7. データモデル

### 7.1 タスクデータモデル

```typescript
interface Task {
  id: string;                    // タスク一意識別子
  title: string;                 // タスク名
  startDate: Date;               // 開始日
  endDate: Date;                 // 終了日
  completed: boolean;            // 完了状態
  assignee?: User;               // 担当者
  priority?: 'low' | 'medium' | 'high'; // 優先度
  tags?: string[];               // タグリスト
  description?: string;          // 詳細説明
  dependsOn?: string[];          // 依存関係（タスクID配列）
  completedAt?: Date;            // 完了日時
  rowIndex?: number;             // 表示順序（オプション）
}

interface User {
  id: string;
  name: string;
  avatarUrl?: string;
}
```

### 7.2 ビュー設定データモデル

```typescript
interface TimelineViewSettings {
  viewMode: 'day' | 'week' | 'month';  // 表示モード
  zoomLevel: number;                   // ズームレベル (50-200%)
  showCompletedTasks: boolean;         // 完了タスク表示フラグ
  showDependencies: boolean;           // 依存関係線表示フラグ
  groupBy?: 'assignee' | 'priority' | 'tags' | null; // グループ化基準
  highlightToday: boolean;             // 今日強調表示フラグ
  highlightWeekends: boolean;          // 週末強調表示フラグ
}
```

---

## 8. テスト要件

### 8.1 ユニットテスト

以下のコンポーネントとフックに対するユニットテストが必要です：

- TimelineView
- TimelineHeader
- TimelineDayHeader
- TimelineItem
- TaskDetailPopover
- useTimelineView
- useTimelineZoom
- useDragAndDrop
- useTaskStatus

各テストでは以下の項目を検証します：

- コンポーネントが正しくレンダリングされるか
- プロップスの変更に正しく反応するか
- イベントハンドラが適切に呼び出されるか
- ステート変更が正しく行われるか

### 8.2 インテグレーションテスト

以下のインタラクションに対するテストが必要です：

- 表示モード切替の動作確認
- 期間ナビゲーションの動作確認
- ズーム操作の動作確認
- タスクの選択操作の動作確認
- ドラッグ＆ドロップ操作の動作確認
- キーボードショートカットの動作確認

### 8.3 パフォーマンステスト

- 大量データ（100件以上）での表示パフォーマンス
- ドラッグ＆ドロップ操作時の描画パフォーマンス
- ズーム操作時の描画パフォーマンス

---

## 9. 実装優先順位

| 機能 | 優先度 | 難易度 | 推定工数 |
|------|--------|--------|----------|
| 基本レイアウト構造 | 高 | 低 | 1日 |
| 日付表示ヘッダー | 高 | 低 | 1日 |
| タスクバー表示 | 高 | 中 | 2日 |
| タスクステータス管理 | 高 | 低 | 1日 |
| 表示モード切替 | 高 | 中 | 1日 |
| 期間ナビゲーション | 高 | 低 | 1日 |
| ドラッグ＆ドロップ（基本） | 高 | 高 | 3日 |
| ズーム機能 | 中 | 中 | 2日 |
| タスク詳細ポップオーバー | 中 | 中 | 1日 |
| キーボードナビゲーション | 中 | 高 | 2日 |
| アクセシビリティ対応 | 中 | 高 | 2日 |
| パフォーマンス最適化 | 低 | 高 | 3日 |

## 10. 開発ガイドライン

### 10.1 コーディング規約

- 各コンポーネントは単一責任の原則に従う
- Props型定義は明示的に行う
- メモ化（React.memo, useMemo, useCallback）を適切に使用
- 再利用可能なロジックはカスタムフックに分離
- Tailwind CSSクラス名の命名規約に従う
- コンポーネントファイル名はPascalCase、関数名はcamelCase

### 10.2 パフォーマンス最適化

- 頻繁に更新される状態と静的な状態を分離
- コンポーネントの不要な再レンダリングを防ぐ
- 大量のデータは仮想化スクロールを使用
- リスト要素には適切なkeyを設定
- ドラッグイベントはdebounce/throttleを適用

---

## 11. 付録

### 11.1 用語集

| 用語 | 定義 |
|------|------|
| タイムライン | タスクを時系列で表示する視覚的なビュー |
| タスク | 特定の期間に実行される作業単位 |
| スナップ | ドラッグ中のオブジェクトが特定のグリッドに吸着する機能 |
| 依存関係 | タスク間の前後関係や親子関係 |
| ズーム | 表示の拡大・縮小機能 |

### 11.2 参考資料

- [React公式ドキュメント](https://reactjs.org/)
- [Tailwind CSS](https://tailwindcss.com/)
- [date-fns（日付操作ライブラリ）](https://date-fns.org/)
- [WCAG 2.1アクセシビリティガイドライン](https://www.w3.org/TR/WCAG21/)
